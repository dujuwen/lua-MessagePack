{
    "docs": [
        {
            "location": "/",
            "text": "lua-MessagePack\n\n\n\n\nOverview\n\n\nMessagePack\n\nis an efficient binary serialization format.\n\n\nIt lets you exchange data among multiple languages\nlike JSON but it's faster and smaller.\n\n\nIt's a pure Lua implementation, without dependency.\n\n\nIt's really fast with LuaJIT.\n\n\nReferences\n\n\nThe MessagePack specification is available at\n\ngithub.com/msgpack/msgpack\n.\n\n\nStatus\n\n\nlua-MessagePack is in production/stable stage.\n\n\nIt's developed for Lua 5.1, 5.2 & 5.3. There are 2 variants:\n\n\n\n\none compatible with all interpreters since Lua 5.1\n\n\nanother which uses the Lua 5.3 features\n\n\n\n\nDownload\n\n\nThe sources are hosted on \nGitHub\n.\n\n\nInstallation\n\n\nlua-MessagePack is available via LuaRocks:\n\n\nluarocks install lua-messagepack\n# luarocks install lua-messagepack-lua53\n\n\n\n\nor manually, with:\n\n\nmake install LUAVER=5.2\n\n\n\n\nTest\n\n\nThe test suite requires the module\n\nlua-TestMore\n.\n\n\nmake test\n\n\n\n\nCopyright and License\n\n\nCopyright \u00a9 2012-2018 Fran\u00e7ois Perrad\n\n\n\n\n\nThis library is licensed under the terms of the MIT/X11 license,\nlike Lua itself.",
            "title": "Home"
        },
        {
            "location": "/#lua-messagepack",
            "text": "",
            "title": "lua-MessagePack"
        },
        {
            "location": "/#overview",
            "text": "MessagePack \nis an efficient binary serialization format.  It lets you exchange data among multiple languages\nlike JSON but it's faster and smaller.  It's a pure Lua implementation, without dependency.  It's really fast with LuaJIT.",
            "title": "Overview"
        },
        {
            "location": "/#references",
            "text": "The MessagePack specification is available at github.com/msgpack/msgpack .",
            "title": "References"
        },
        {
            "location": "/#status",
            "text": "lua-MessagePack is in production/stable stage.  It's developed for Lua 5.1, 5.2 & 5.3. There are 2 variants:   one compatible with all interpreters since Lua 5.1  another which uses the Lua 5.3 features",
            "title": "Status"
        },
        {
            "location": "/#download",
            "text": "The sources are hosted on  GitHub .",
            "title": "Download"
        },
        {
            "location": "/#installation",
            "text": "lua-MessagePack is available via LuaRocks:  luarocks install lua-messagepack\n# luarocks install lua-messagepack-lua53  or manually, with:  make install LUAVER=5.2",
            "title": "Installation"
        },
        {
            "location": "/#test",
            "text": "The test suite requires the module lua-TestMore .  make test",
            "title": "Test"
        },
        {
            "location": "/#copyright-and-license",
            "text": "Copyright \u00a9 2012-2018 Fran\u00e7ois Perrad   This library is licensed under the terms of the MIT/X11 license,\nlike Lua itself.",
            "title": "Copyright and License"
        },
        {
            "location": "/messagepack/",
            "text": "MessagePack\n\n\n\n\nReference\n\n\npack( data )\n\n\nSerialize a \ndata\n.\n\n\nunpack( str )\n\n\nDeserialize a \nstring\n.\n\n\nunpacker( src )\n\n\nAccept a \nstring\n or a \nltn12.source\n\nand returns a iterator.\n\n\nThe iterator gives a couple of values,\nthe \ninteresting\n value is the second.\n\n\nset_number( str )\n\n\nConfigures the behaviour of \npack\n.\nThe valid options are \n'double'\n and \n'float'\n.\nThe default is \nusually\n \n'double'\n.\n\n\nset_integer( str ) DEPRECATED\n\n\nConfigures the behaviour of \npack\n.\nThe valid options are \n'signed'\n and \n'unsigned'\n.\nThe default is \n'unsigned'\n.\n\n\nset_array( str )\n\n\nConfigures the behaviour of \npack\n.\nThe valid options are \n'without_hole'\n, \n'with_hole'\n and \n'always_as_map'\n.\nThe default is \n'without_hole'\n.\n\n\nset_string( str )\n\n\nConfigures the behaviour of \npack\n.\nThe valid options are \n'string'\n, \n'string_compat'\n and \n'binary'\n.\nThe default is \n'string_compat'\n in order to be compatible with old implementation.\n\n\nData Conversion\n\n\n\n\nThe following \nLua\n types could be converted :\n  \nnil\n, \nboolean\n, \nnumber\n, \nstring\n and \ntable\n.\n\n\nA \nLua\n \nnumber\n is converted into an \nMessagePack\n \ninteger\n\n  if \nmath.floor(num) == num\n, otherwise it is converted\n  into the \nMessagePack\n \nfloat\n or \ndouble\n (see \nset_number\n).\n\n\nWhen a \nMessagePack\n 64 bits \ninteger\n is converted to a \nLua\n \nnumber\n\n  it is possible that the resulting number will not represent the original number but just an approximation.\n\n\nA \nLua\n \ntable\n is converted into a \nMessagePack\n \narray\n\n  only if \nall\n the keys are composed of strictly positive integers,\n  without hole or with holes (see \nset_array\n).\n  Otherwise it is converted into \nMessagePack\n \nmap\n.\n\n\nAn empty \ntable\n is always converted into a \nMessagePack\n \narray\n.\n\n\nWith \nset_array'always_as_map'\n,\n  all \nLua\n \ntable\n are converted into a \nMessagePack\n \nmap\n.\n\n\nLua does not allow \nnil\n and \nNaN (0/0)\n as \ntable\n index, by default,\n  the deserialization of this kind of \nMessagePack\n map skips the key/value pair.\n  The value could preserved by defining the module member \nsentinel\n which is used as key.\n\n\nLIMITATION : \nMessagePack\n cannot handle data with \ncyclic\n reference.\n\n\n\n\nExtensions\n\n\nThere are introduced with \nMessagePack\n specification v5.\n\n\nDuring deserialization, unknown extensions are skipped\nand evaluated as a \nLua\n \nnil\n.\n\n\nThe following example shows how to create a new module\nwhich extends \nMessagePack\n with the serialization/deserialization\nof \nLua\n \nfunction\n (obviously,\nthe emitter and receiver MUST use the same version of Lua).\n\n\nlocal loadstring = loadstring or load\nlocal mp = require 'MessagePack'\nlocal EXT_FUNCTION = 7\n\nmp.packers['function'] = function (buffer, fct)\n    mp.packers['ext'](buffer, EXT_FUNCTION, assert(string.dump(fct)))\nend\n\nmp.build_ext = function (tag, data)\n    if tag == EXT_FUNCTION then\n        return assert(loadstring(data))\n    end\nend\n\nreturn mp\n\n\n\n\nAdvanced usages\n\n\nThe following Lua hack allows to have several instances\nof the module \nMessagePack\n, each one with its own settings.\n\n\nlocal mp1 = require 'MessagePack'\npackage.loaded['MessagePack'] = nil     -- the hack is here\nlocal mp2 = require 'MessagePack'\n\nmp1.set_array'without_hole'\nmp2.set_array'always_as_map'\n\n\n\n\nWhen global settings are not enough,\nthe following recipe allows to use a specific encoding\nfor only a part of a data structure.\n\n\nlocal mp = require 'MessagePack'\nmp.packers['function'] = function (buffer, fct)\n    fct(buffer)\nend\n\nlocal function BINARY (str)\n    return function (buffer)\n        mp.packers['binary'](buffer, str)\n    end\nend\n\nlocal function FLOAT (n)\n    return function (buffer)\n        mp.packers['float'](buffer, n)\n    end\nend\n\nmp.pack { 'encoded_with_global_settings', BINARY'encoded_as_binary', 42, FLOAT(42) }\n\n\n\n\nExamples\n\n\nBasic usage\n\n\nlocal mp = require 'MessagePack'\n\nmp.set_number'float'\nmp.set_array'with_hole'\nmp.set_string'string'\n\nmpac = mp.pack(data)\ndata = mp.unpack(mpac)\n\nlocal ltn12 = require 'ltn12'\nsrc = ltn12.source.file(io.open('file', 'r'))\nfor _, v in mp.unpacker(src) do\n    print(v)\nend",
            "title": "API"
        },
        {
            "location": "/messagepack/#messagepack",
            "text": "",
            "title": "MessagePack"
        },
        {
            "location": "/messagepack/#reference",
            "text": "",
            "title": "Reference"
        },
        {
            "location": "/messagepack/#pack-data",
            "text": "Serialize a  data .",
            "title": "pack( data )"
        },
        {
            "location": "/messagepack/#unpack-str",
            "text": "Deserialize a  string .",
            "title": "unpack( str )"
        },
        {
            "location": "/messagepack/#unpacker-src",
            "text": "Accept a  string  or a  ltn12.source \nand returns a iterator.  The iterator gives a couple of values,\nthe  interesting  value is the second.",
            "title": "unpacker( src )"
        },
        {
            "location": "/messagepack/#set_number-str",
            "text": "Configures the behaviour of  pack .\nThe valid options are  'double'  and  'float' .\nThe default is  usually   'double' .",
            "title": "set_number( str )"
        },
        {
            "location": "/messagepack/#set_integer-str-deprecated",
            "text": "Configures the behaviour of  pack .\nThe valid options are  'signed'  and  'unsigned' .\nThe default is  'unsigned' .",
            "title": "set_integer( str ) DEPRECATED"
        },
        {
            "location": "/messagepack/#set_array-str",
            "text": "Configures the behaviour of  pack .\nThe valid options are  'without_hole' ,  'with_hole'  and  'always_as_map' .\nThe default is  'without_hole' .",
            "title": "set_array( str )"
        },
        {
            "location": "/messagepack/#set_string-str",
            "text": "Configures the behaviour of  pack .\nThe valid options are  'string' ,  'string_compat'  and  'binary' .\nThe default is  'string_compat'  in order to be compatible with old implementation.",
            "title": "set_string( str )"
        },
        {
            "location": "/messagepack/#data-conversion",
            "text": "The following  Lua  types could be converted :\n   nil ,  boolean ,  number ,  string  and  table .  A  Lua   number  is converted into an  MessagePack   integer \n  if  math.floor(num) == num , otherwise it is converted\n  into the  MessagePack   float  or  double  (see  set_number ).  When a  MessagePack  64 bits  integer  is converted to a  Lua   number \n  it is possible that the resulting number will not represent the original number but just an approximation.  A  Lua   table  is converted into a  MessagePack   array \n  only if  all  the keys are composed of strictly positive integers,\n  without hole or with holes (see  set_array ).\n  Otherwise it is converted into  MessagePack   map .  An empty  table  is always converted into a  MessagePack   array .  With  set_array'always_as_map' ,\n  all  Lua   table  are converted into a  MessagePack   map .  Lua does not allow  nil  and  NaN (0/0)  as  table  index, by default,\n  the deserialization of this kind of  MessagePack  map skips the key/value pair.\n  The value could preserved by defining the module member  sentinel  which is used as key.  LIMITATION :  MessagePack  cannot handle data with  cyclic  reference.",
            "title": "Data Conversion"
        },
        {
            "location": "/messagepack/#extensions",
            "text": "There are introduced with  MessagePack  specification v5.  During deserialization, unknown extensions are skipped\nand evaluated as a  Lua   nil .  The following example shows how to create a new module\nwhich extends  MessagePack  with the serialization/deserialization\nof  Lua   function  (obviously,\nthe emitter and receiver MUST use the same version of Lua).  local loadstring = loadstring or load\nlocal mp = require 'MessagePack'\nlocal EXT_FUNCTION = 7\n\nmp.packers['function'] = function (buffer, fct)\n    mp.packers['ext'](buffer, EXT_FUNCTION, assert(string.dump(fct)))\nend\n\nmp.build_ext = function (tag, data)\n    if tag == EXT_FUNCTION then\n        return assert(loadstring(data))\n    end\nend\n\nreturn mp",
            "title": "Extensions"
        },
        {
            "location": "/messagepack/#advanced-usages",
            "text": "The following Lua hack allows to have several instances\nof the module  MessagePack , each one with its own settings.  local mp1 = require 'MessagePack'\npackage.loaded['MessagePack'] = nil     -- the hack is here\nlocal mp2 = require 'MessagePack'\n\nmp1.set_array'without_hole'\nmp2.set_array'always_as_map'  When global settings are not enough,\nthe following recipe allows to use a specific encoding\nfor only a part of a data structure.  local mp = require 'MessagePack'\nmp.packers['function'] = function (buffer, fct)\n    fct(buffer)\nend\n\nlocal function BINARY (str)\n    return function (buffer)\n        mp.packers['binary'](buffer, str)\n    end\nend\n\nlocal function FLOAT (n)\n    return function (buffer)\n        mp.packers['float'](buffer, n)\n    end\nend\n\nmp.pack { 'encoded_with_global_settings', BINARY'encoded_as_binary', 42, FLOAT(42) }",
            "title": "Advanced usages"
        },
        {
            "location": "/messagepack/#examples",
            "text": "Basic usage  local mp = require 'MessagePack'\n\nmp.set_number'float'\nmp.set_array'with_hole'\nmp.set_string'string'\n\nmpac = mp.pack(data)\ndata = mp.unpack(mpac)\n\nlocal ltn12 = require 'ltn12'\nsrc = ltn12.source.file(io.open('file', 'r'))\nfor _, v in mp.unpacker(src) do\n    print(v)\nend",
            "title": "Examples"
        }
    ]
}